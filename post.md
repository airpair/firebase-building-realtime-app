## 1 Intro to Firebase

[Firebase](https://www.firebase.com/) is a realtime database that you can communicate with directly from the client. When you save your JSON data to Firebase, changes are sent instantly to all clients, web and mobile, that requested them. With built-in static file hosting, user management, and security rules, Firebase will help you build modern applications faster than ever. 

This tutorial will help you understand some of the key concepts behind Firebase and its API. We'll be creating a simple realtime analytics tool that will display metrics about our site and what our visitors are viewing in realtime. All of our JavaScript code will run entirely within a web browser, but Firebase supports many other languages and environments, including Node.js, Objective-C (iOS/OS X), Java (Android). It also provides a REST API so you can read and write data from any server, even if there's no officially supported SDK. We'll use jQuery to update the DOM in our analytics dashboard. Most applications, however, should opt to use a framework like Angular, Backbone, Ember, or React, all of which have Firebase libraries for easy integration. 

## 2 Firebase Concepts

### 2.1 Leaving Behind Request-Reply

Firebase uses an event-driven model to notify us of changes to our data as well as supply the data when it first arrives. You should be familiar with evented programming if you've used Node.js before, but we'll review since it differs substantially from the traditional request-reply model most applications use. In the request-reply model, your application sends data off to your server. Your server might interact with a SQL (or NoSQL) database and possibly even external APIs before replying back to your client with the data it requested. Once that reply is received, the exchange is over. Your client application always knows when it will receive new data because it always has to explicitly request it before anything is received.

### 2.2 Entering Event-Driven

When we use events to receive our data, our handlers are not just called once after the server replies. Instead, they may be called a number of timesâ€”once to send us the data the first time and then once each time our data *changes*. Let's look at a simplified example borrowed from later in the tutorial:

<!--code lang=javascript linenums=true-->

    function logVisitorCount (snapshot) {
      console.log('There are currently ', snapshot.val(), ' visitors on the site');
    }
    totalVisitors.on('value', logVisitorCount);

`totalVisitors` is a Firebase reference. We'll cover how to create these soon. Here, we're attaching a listener for the `'value'` event using the `on` method, passing a callback `logVisitorCount`. The Firebase JavaScript API will call our `logVisitorCount` function every time the value located at `totalVisitors` changes. Instead of requesting the data explicitly, either the first time or to refresh old data, Firebase instead tells us when there's new data so we can update the content on screen.

### 2.3 Schema

At its core, a Firebase database is just a big JSON object. There are no tables. There aren't even analogues to collections and documents from MongoDB. You can organize your data however you'd like, change your schema at any time, and nest objects and values as deeply as you want. This becomes extremely valuable when prototyping an application. Here's the schema we're going to use for our analytics application, including sample data:

<!--code lang=http linenums=true -->

    {
      "totalVisitors": 5,
      "activeVisitors": {
        "-IKo28nwJLH0Nc5XeFmj": {
          "path": "/",
          "arrivedAt": 1413392152630,
          "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.124 Safari/537.36"
        }
      },
      "pastVisitors": {
        "-INOQPH-aV_psbk3ZXEX": {
          "path": "/",
          "arrivedAt": 1413392151219,
          "leftAt": 1413392155419,
          "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.124 Safari/537.36"
        }
      }
    }

You'll notice that the keys of `activeVisitors` and `pastVisitors` have long randomized names. This is because Firebase cannot use traditional arrays with numeric keys or we'd create collisions and override take. Take this simple example:

<!--code lang=javascript linenums=true-->

    // ref = ['foo'];
    ref.push('bar');

At the same time, another client calls:

<!--code lang=javascript linenums=true-->

    ref.push('baz');

What happens? If we're using traditional JavaScript arrays with numeric keys, both clients try to write to `ref[1]`. Whoever gets to the server last will overwrite the data that arrived first. We certainly don't want this. Instead of using arrays, collections of ordered data in Firebase are represented by objects with autogenerated keys that look like `'-IKo28nwJLH0Nc5XeFmj'`. These keys are generated automatically and encode both the timestamp and a unique client ID. This way multiple clients can write data at the same time with collisions and your data will still be returned in order.

Since data in Firebase is always hierarchical, you can access it using a URL path. The root of a Firebase database called `airpair-analytics-tutorial` will be `https://airpair-analytics-tutorial.firebaseio.com`. To access the `pastVisitors` data directly, we can modify that to `https://airpair-analytics-tutorial.firebaseio.com`.

## 3 Getting Started

You'll want to start by creating a [Firebase](http://www.firebase.com) account. Firebase's "Hacker" plan is free for up to 50 connections, 100MB of storage, and 5GB of transfer. When you create your first database, you'll be taken to Forge, Firebase's web interface for viewing and editing your data as well as changing database settings. 

### 3.1 Setting Up Our Project

We're going to be creating two major components: code to send our analytics data to Firebase and a simple dashboard to read our data out. Our project will look like this:

<!--code lang=markup linenums=true-->

    analytics.js
    dashboard.js
    dashboard.html
    sample-page/
     index.html

We'll work on `analytics.js` first where we'll be writing all of our analytics data to Firebase. Because we can see all of our data update in realtime in Forge, we can tackle all of our analytics code before moving on and displaying it in the dashboard. 

## 4 Writing to Firebase

When a user opens our page, we want to save the time, the path they visited, and their user agent to our list of active visitors. We'll need to create a reference to our `activeVisitors` collection before we can save to it. To create a new Firebase reference, we'll do the following:

<!--code lang=javascript linenums=true-->

    var analytics = new Firebase('https://airpair-analytics-tutorial.firebaseio.com/');

You can copy and paste the path directly from Firebase Forge. We could create a reference directly to our `activeVisitors` data like this:

<!--code lang=javascript linenums=true-->

    var activeUsers = new Firebase('https://airpair-analytics-tutorial.firebaseio.com/activeUsers');

Since we want to write data to other places in our database later, we'll use the `child` method instead to keep our root reference but also reference our `activeVisitors` data:

<!--code lang=javascript linenums=true-->

    var analytics = new Firebase('https://airpair-analytics-tutorial.firebaseio.com/');
    var activeVisitors = analytics.child('activeVisitors');

Now we can `push` our user data when they arrive:

<!--code lang=javascript linenums=true-->

    activeVisitors.push({
      path: window.location.pathname,
      arrivedAt: Firebase.ServerValue.TIMESTAMP,
      userAgent: navigator.userAgent
    });

You'll notice that rather than `Date.now()`, we're using `Firebase.ServerValue.TIMESTAMP` for the `arrivedAt` timestamp. This value will be replaced by Firebase when it receives our data with a timestamp from the server. This way, even if all our clients' clocks aren't set correctly, our data will always be in the correct order. 

### 4.1 Installing analytics.js

Moving over to `sample-page/index.html`, let's add the script tags we'll need to write our data to Firebase to the end of the `<body>` of our document:

<!--code lang=markup linenums=true-->

    <script src='https://cdn.firebase.com/js/client/1.1.1/firebase.js'></script>
    <script src='../analytics.js'></script>

Now we can open our sample page in a browser alongside Firebase Forge and watch our visitor data get written to Firebase every time we refresh!

### 4.2 Updating the Visitors Count

Next we'll work on the `totalVisitors` property in our schema which will display the current number of active sessions. In order to increment the `totalVisitors`, we'll need to actually get the value from Firebase. The most obvious way to do that would be to ask for the value once, add 1 to it, and set it to our new value. We could do that like this:

<!--code lang=javascript linenums=true-->

    var totalVisitors = analytics.child('totalVisitors');
    totalVisitors.once('value', function (snapshot) {
      totalVisitors.set(snapshot.val() + 1);
    });

Let's dive in and look at exactly what all these methods do. `once` registers a listener that will receive data only once and stop listening. It registers on `'value'` so that it will receive the value stored at `https://airpair-analytics-tutorial.firebaseio.com/totalVisitors`. The callback function we've passed as the second argument to `once` will be called by Firebase with a [DataSnapshot](https://www.firebase.com/docs/web/api/datasnapshot/). DataSnapshots are copies of the data at that reference in Firebase. They never change. When using a normal `on` handler, you'll receive a new snapshot every time your data at that reference changes. Snapshots have a number of methods, but the most important are:
* `val`: returns the data at the snapshot
* `name`: returns the key (in this case `totalVisitors`)

When we get the snapshot, we get its value with `snapshot.val()` and add one to it. We `set` that value on our `totalVisitors` reference to update the data there. Note that `set` will override any existing data at that reference, even an object.

You can go ahead and try this code. At first glance, it seems to work fine. However, you'll notice that we've uncovered a similar realtime problem we encountered before: what happens when multiple clients try to write at the same time? Say `totalVisitors === 0`. When two clients load our analytics script at the same time, they will both receive a snapshot with the count as 0. They'll both add 1 for a total of 1 and they'll both simultaneously write 1 to Firebase. Instead of the correct value, 2, we end up with 1. 

Luckily Firebase has a way of addressing this that should be familiar to SQL users: transactions. Firebase allows us to pass a function which takes a reference's value as an argument and returns the new value that it should take on. If any other client writes to that reference before our transaction is written, it will run again until the write succeeds and there are no conflicts. Let's reimplement our `totalVisitors` incrementing logic with transactions so multiple clients don't overwrite each other:

<!--code lang=javascript linenums=true-->

    var totalVisitors = analytics.child('totalVisitors');
    totalVisitors.transaction(function (currentData) {
      return currentData + 1;
    });

Now multiple visitors can arrive at the same time and our visitor counter will still have the correct value. 

### 4.3 Updating Data on Disconnect

We've added all the data we need. But we will still need to update our records when a visitor disconnects. Whether that's because they lose their internet connection, close their browser, or navigate to a different page, Firebase can help us update our database when that happens with just a few lines of code.

When a visitor disconnects, we will need to:

1. Record the time they left.
2.  Move their visit from `activeVisitors` to `pastVisitors`.

Let's first tackle writing the visitor data to `pastVisitors`. Instead of pushing an object directly to `activeVisitors` as we did before, let's save it as a variable so that we can reuse it later. We'll also need to get our data:

<!--code lang=javascript linenums=true-->

    var visitor = {
      path: window.location.pathname,
      arrivedAt: Firebase.ServerValue.TIMESTAMP,
      userAgent: navigator.userAgent
    };

    var activeVisitorRef = activeVisitors.push(visitor, function () {
      activeVisitors.child(visitorId).once('value', function (snapshot) {
        visitor.arrivedAt = snapshot.child('arrivedAt').val();
        var pastVisitors = analytics.child('pastVisitors');
        visitor.leftAt = Firebase.ServerValue.TIMESTAMP;
        pastVisitors.child(visitorId).onDisconnect().set(visitor);
      });
    });

    var visitorId = activeVisitorRef.name();

Now you can open the sample page in your browser. If you refresh, you'll notice that there is an entry in `pastVisitors` with the timestamp of when you refreshed. We've used a significant number of new API methods here so let's step back and dissect all the new methods we're using here. 

We're taking advantage of two properties of `ref.push` that we weren't using before. First, it returns a Firebase reference to the location where our data will be written. As you may remember from before, the cryptic-looking random ID Firebase generates encodes the client timestamp and a unique client ID. Both of these values are generated by the client itself even before a server connection is made. We're calling `ref.name()` on our reference in order to get its keys, which is the randomly generated ID. We'll need this value later, but let's first look at the callback we're now passing to `ref.push`.

This callback will be called with an `Error` if one occurs, otherwise with `null`. We won't handle errors in this tutorial for the sake of time, but you certainly should in your applications. Once our data has been successfully written, we attach a `'once'` that will be register a callback to be triggered a single time with the value as it exists on the server. This allows us to read the server timestamp which we're using instead of a `Date.now()` client timestamp for accuracy. We overwrite the server timestamp on our `visitor` object because we'll be saving that same object to `pastVisitors` later and we want the current timestamp in `arrivedAt`, not a timestamp from when the visitor disconnects. 

Next we'll add a `visitor.leftAt` timestamp. We'll let Firebase's servers set this for consistency and accuracy. We're setting this after `activeVisitors.push` has successfully written so the timestamp won't actually be parsed until our client actually disconnects. Here's where the `visitorId` that we stored earlier will come in handy. We'll create a reference on `pastVisitors` with a key equal to our `visitorId`. Don't worry that there isn't any data here yet. Firebase treats empty references as null, no matter how deeply they are nested. We'll use the Firebase [`onDisconnect`](https://www.firebase.com/docs/web/api/ondisconnect/) methods and set our `visitor` object. This write won't actually be executed until Firebase loses its connection with the client.

Finally, we'll need to remove the visitor from our active visitors when the visitor disconnects.

<!--code lang=javascript linenums=true-->

    activeVisitorRef.onDisconnect().remove();

It's that easy! Just one line.

## 5 Reading from Firebase

Now that we've built our analytics script that we can embed on our site, we can start to display some of the data we've collected in real time. We'll first set up our `dashboard.html` file with some empty elements that we can begin to fill with our data. Our HTML will look like this:

<!--code lang=markup linenums=true-->

    <span>Analytics Dashboard</span>
    <section>
      <span>Total Visitors: <span id="total-visitors"></span></span>
    </section>
    <section>
      <span>Active Visitors</span>
      <ul id="active-visitors"></ul>
    </section>
    <section>
      <span>Past Visitors</span>
      <ul id="past-visitors"></ul>
    </section>
    <script src='https://cdn.firebase.com/js/client/1.1.1/firebase.js'></script>
    <script src='https://code.jquery.com/jquery-2.1.1.js'></script>
    <script src='./dashboard.js'></script>

### 5.1 Updating Values

As mentioned earlier, a data binding tool like Angular, Backbone, Ember, or React would be helpful here. For the sake of simplicity, we're going to manage our DOM elements manually in this tutorial. We're using jQuery for convenience. We'll be working in `dashboard.js` now.

Let's first update the total visitors tally, since that only represents a single value.

<!--code lang=javascript linenums=true-->

    $(document).on('ready', function () {
      var $totalVisitors = $('#total-visitors');
      analytics.child('totalVisitors').on('value', function (snapshot) {
        $totalVisitors.text(snapshot.val());
      });
    });

### 5.2 Updating Collections of Data

Collections of data are somewhat more complicated to manage. Firebase provides several events that allow you to be notified when the contents of an object change in specific ways:

* \+ child_added
* \+ child_removed
* \+ child_changed
* \+ child_moved

`'child_changed'` and `'child_moved'` are somewhat more complicated to handle, so we won't be using them here. First we'll want to display new sessions when they are added. It's important to note that `'child_added'` events are fired for each child when they are first attached using `on` and then again for new children after your application has loaded. This conveniently allows you to keep all your logic in one place instead of requesting the data initially and then trying to keep it in sync as updates come in.

<!--code lang=javascript linenums=true-->

    var $activeVisitors = $('#active-visitors');
    var activeVisitors = analytics.child('activeVisitors');
    activeVisitors.on('child_added', function (snapshot) {
      var n = snapshot.name();
      var v = snapshot.val();
      $activeVisitors.prepend(
      '<li id="active-visitor' + n + '">' + n + ':' +
        '<ul>' +
          '<li>Arrived: ' + new Date(v.arrivedAt) + '</li>' +
          '<li>Path: ' + v.path + '</li>' +
          '<li>User Agent: ' + v.userAgent + '</li>' +
        '</ul>' + 
      '</li>'
      );
    });

We did a lot here, so let's stop to review what's going on. Every time a `'child_added'` event is fired, we're adding a new `<li>` element to our initially empty `<ul>` element. It contains the generated ID of our visitor and displays the visitor data in bullet points. It's also important to note that we're setting our element's id equal to `active-visitor{{id}}` where `{{id}}` is the visitor's auto-generated ID. 

We'll add very similar code for displaying past visitors as well:

<!--code lang=javascript linenums=true-->

    var pastVisitors = analytics.child('pastVisitors');
    pastVisitors.on('child_added', function (snapshot) {
      var n = snapshot.name();
      var v = snapshot.val();
      $pastVisitors.prepend(
      '<li id="past-visitor' + n + '">' + n + ':' +
        '<ul>' +
          '<li>Arrived: ' + new Date(v.arrivedAt) + '</li>' +
          '<li>Left: ' + new Date(v.leftAt) + '</li>' +
          '<li>Spent: ' + ((v.leftAt - v.arrivedAt) / 1000) + ' Seconds </li>' +
          '<li>Path: ' + v.path + '</li>' +
          '<li>User Agent: ' + v.userAgent + '</li>' +
        '</ul>' + 
      '</li>'
      );
    });

This time, we'll also display when they left as well as how long they were visiting the page in seconds. 

Our code works and we can refresh our sample page and watch as visits are displayed in our dashboard. However, you'll notice that you need to refresh the page in order to remove active visitors even though they have been removed in Firebase. To handle that automatically, we'll need to add handlers for the `'child_removed'` event. 

<!--code lang=javascript linenums=true-->

    activeVisitors.on('child_removed', function (snapshot) {
      $('#active-visitor' + snapshot.name()).remove(); 
    });

Now you'll see that active visitors are removed from the dashboard dsiplay and mirror what we see on Firebase.

## 6 Working with queries

If you're used to SQL, you may be wondering how you filter data. You don't have the same flexibility that you would with a SQL where clause, but Firebase does provide several methods for limiting the data you receive. We'll cover these very briefly, but know that queries in Firebase can be quite powerful when used well.

Even if our website isn't especially popular, we probably don't want every past visit displayed when we open up our dashboard. While Firebase is fairly clever about breaking data into chunks so you don't see an empty display for too long, it would still be unnecessarily inefficient and distracting to see all those visits. If you've looked at your visit data in Forge, you'll notice that it's ordered from earliest to latest even though we're displaying data in reverse in our dashboard. Let's only display the 3 most recent visits in our past visits list.

<!--code lang=javascript linenums=true-->

    var pastVisitors = analytics.child('pastVisitors').endAt().limit(3);
    pastVisitors.on('child_added', function (snapshot) {
     // ...
    });

You'll notice that this requires only a small change to a single line of code. We call `endAt()` on our reference to tell Firebase we want to perform our query at the end of our data set, then `limit(3)` to limit our query to 3 records. If you refresh the dashboard, you'll notice that only the three most recent records appear. Success!

Well, close. You'll notice that as more visitors leave, our dashboard never removes the oldest visits and the number displayed exceeds 3. We can handle this just like we did before, by adding a `'child_removed'` handler.

<!--code lang=javascript linenums=true-->

     pastVisitors.on('child_removed', function (snapshot) {
        $('#past-visitor' + snapshot.name()).remove(); 
      });

Now you can refresh our sample page and notice that Past Visitors is limited to the 3 most recent visits at all times. You'll notice that `'child_removed'` doesn't actually indicate that the data has been deleted, just that it is no longer part of our *reference* where we attached the event.

## 7 Conclusion  

Firebase is a great tool for speeding up the time it takes to build realtime applications. We've give you a high-level look at some core concepts and shown you how to put it into production immediately with a sample application and code -- now give it a shot for yourself! If you have any questions or run into any trouble, be sure to book me for an AirPair! 